## 错误捕获
### try/catch
只能捕捉到的异常是必须是线程执行已经进入 try catch 但 try catch 未执行完的时候抛出来的。（<b>异步异常无法捕获</b>、<b>语法错误无法捕获</b>）

#### 语法错误
在进入 try catch 前，语法错误就已经被监测出来，此时 try catch 就无法捕获错误。

```js
try {
  name.
} catch(e) {
  console.log("error", e);
}
// output
Uncaught SyntaxError: Unexpected token '}'
```

### 异步错误
在 try catch 后，异步错误即使报错了，此时 try catch 也无法捕获错误。

```js
try {
  setTimeout(() => {
    console.log(myName.length)
  }, 200)
} catch(e) {
  console.log("error", e);
}
// output
Uncaught ReferenceError: myName is not defined
```

### window.onerror
能捕获<b>异步错误</b>，但无法捕获<b>资源异常错误</b>和<b>常规错误</b>。

```js
/**
 * @param { string } message 错误信息
 * @param { string } source 发生错误的脚本URL
 * @param { number } lineno 发生错误的行号
 * @param { number } colno 发生错误的列号
 * @param { object } error Error对象
 */
window.onerror = function (message, source, lineno, colno, error) {
  console.log('捕获到的错误信息是：', message, source, lineno, colno, error);
};

// 异步错误 ✅
setTimeout(() => {
  console.log(n.n)
}, 300)
// output
捕获到的错误信息是： Uncaught ReferenceError: n is not defined  2 17 ReferenceError: n is not defined at <anonymous>:2:17
// 错误
Uncaught ReferenceError: n is not defined at <anonymous>:2:17

// 常规错误 ❌ 未捕获到
console.log(n.n)
// output
Uncaught ReferenceError: n is not defined at <anonymous>:1:13

// 资源错误 ❌ 未捕获到
const script = document.createElement("script");
script.type = "text/javascript";
// 资源地址是错误的
script.src = "https://www.yuguoping.com/test.js";
document.body.appendChild(script);
// 无响应
```

### window.addEventListener
能捕获<b>异步错误</b>和<b>资源错误</b>，但不能捕获<b>常规错误</b>。

```js
window.addEventListener('error', (error) => {
  console.log('捕获到异常：', error);
}, true)

// 异步错误 ✅
setTimeout(() => {
  console.log(n.n)
}, 300)
// output
捕获到异常：ErrorEvent
// 错误
Uncaught ReferenceError: n is not defined at <anonymous>:2:17

// 常规错误 ❌ 未捕获到
console.log(n.n)
// 错误
Uncaught ReferenceError: n is not defined at <anonymous>:1:13

// 资源错误 ✅
const script = document.createElement("script");
script.type = "text/javascript";
// 资源地址是错误的
script.src = "https://www.yuguoping.com/test.js";
document.body.appendChild(script);
// output
捕获到异常：ErrorEvent
```

### Promise 错误
Promise 中抛出的错误，无法被 window.onerror、try/catch、 error 事件捕获到，可通过 unhandledrejection 事件来处理

```js
try {
  new Promise((resolve, reject) => {
    JSON.parse('');
    resolve();
  });
} catch (err) {
  // try/catch 不能捕获 Promise 中错误
  console.error('in try catch', err);
}

// error事件 不能捕获 Promise 中错误
window.addEventListener(
  'error',
  (error) => {
    console.log('捕获到异常 error：', error);
  },
  true
);

// window.onerror 不能捕获P romise 中错误 ❌
window.onerror = function (message, source, lineno, colno, error) {
  console.log('捕获到异常 onerror：', { message, source, lineno, colno, error });
};

// unhandledrejection 可以捕获Promise中的错误 ✅
window.addEventListener('unhandledrejection', function (e) {
  console.log('捕获到异常 unhandledrejection', e);
  // preventDefault阻止传播，不会在控制台打印
  e.preventDefault();
});

// output
捕获到异常 unhandledrejection PromiseRejectionEven
```

### react
在 react 中可以使用 class 组件的 componentDidCatch 函数监听错误。react 组件执行的错误不会被抛出至 window.onerror 和 error 。

### vue
在 vue 中 window.onerror 和 error 不能捕获到 vue 内部执行产生的错误，需要使用 Vue.config.errorHandler 来捕获异常。

### 跨域问题
由于浏览器基于安全考虑，故意隐藏了其它域 JS 文件抛出的具体错误信息，这样可以有效避免敏感信息无意中被第三方(不受控制的)脚本捕获到，因此只能捕获到 script error。
解决方法：
+ 前端 script 加 crossorigin
+ 后端配置 Access-Control-Allow-Origin

## 接口监控
接口监控的实现原理：针对浏览器内置的 XMLHttpRequest、fetch 对象，利用 AOP 切片编程重写该方法，实现对请求的接口拦截，从而获取接口报错的情况并上报。注意 polyfill(不支持 fetch 的浏览器可能使用 XMLHttpRequest 实现 fetch，需要确保复写的时机)。

#### XMLHttpRequest
```js
function xhrReplace() {
  if (!('XMLHttpRequest' in window)) {
    return;
  }
  const originalXhrProto = XMLHttpRequest.prototype;
  // 重写XMLHttpRequest 原型上的open方法
  replaceAop(originalXhrProto, 'open', (originalOpen) => {
    return function (...args) {
      // 获取请求的信息
      this._xhr = {
        method: typeof args[0] === 'string' ? args[0].toUpperCase() : args[0],
        url: args[1],
        startTime: new Date().getTime(),
        type: 'xhr'
      };
      // 执行原始的open方法
      originalOpen.apply(this, args);
    };
  });
  // 重写XMLHttpRequest 原型上的send方法
  replaceAop(originalXhrProto, 'send', (originalSend) => {
    return function (...args) {
      // 当请求结束时触发，无论请求成功还是失败都会触发
      this.addEventListener('loadend', () => {
        const { responseType, response, status } = this;
        const endTime = new Date().getTime();
        this._xhr.reqData = args[0];
        this._xhr.status = status;
        if (['', 'json', 'text'].indexOf(responseType) !== -1) {
          this._xhr.responseText =
            typeof response === 'object' ? JSON.stringify(response) : response;
        }
        // 获取接口的请求时长
        this._xhr.elapsedTime = endTime - this._xhr.startTime;

        // 上报xhr接口数据
        reportData(this._xhr);
      });
      // 执行原始的send方法
      originalSend.apply(this, args);
    };
  });
}

/**
 * 重写指定的方法
 * @param { object } source 重写的对象
 * @param { string } name 重写的属性
 * @param { function } fn 拦截的函数
 */
function replaceAop(source, name, fn) {
  if (source === undefined) return;
  if (name in source) {
    var original = source[name];
    var wrapped = fn(original);
    if (typeof wrapped === 'function') {
      source[name] = wrapped;
    }
  }
}
```

#### fetch
```js
function fetchReplace() {
  if (!('fetch' in window)) {
    return;
  }
  // 重写fetch方法
  replaceAop(window, 'fetch', (originalFetch) => {
    return function (url, config) {
      const sTime = new Date().getTime();
      const method = (config && config.method) || 'GET';
      let handlerData = {
        type: 'fetch',
        method,
        reqData: config && config.body,
        url
      };

      return originalFetch.apply(window, [url, config]).then(
        (res) => {
          // res.clone克隆，防止被标记已消费
          const tempRes = res.clone();
          const eTime = new Date().getTime();
          handlerData = {
            ...handlerData,
            elapsedTime: eTime - sTime,
            status: tempRes.status
          };
          tempRes.text().then((data) => {
            handlerData.responseText = data;
            // 上报fetch接口数据
            reportData(handlerData);
          });

          // 返回原始的结果，外部继续使用then接收
          return res;
        },
        (err) => {
          const eTime = new Date().getTime();
          handlerData = {
            ...handlerData,
            elapsedTime: eTime - sTime,
            status: 0
          };
          // 上报fetch接口数据
          reportData(handlerData);
          throw err;
        }
      );
    };
  });
}
```